// CgiProcess.cpp
#include "CgiProcess.hpp"
#include "Color_Macros.hpp"
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <iostream>
#include <cstdlib> // Pour _exit()
#include <errno.h>
#include <cstring> // Pour strerror()

CgiProcess::CgiProcess(const std::string& scriptWorkingDir, const std::string& relativeFilePath,
                       const std::map<std::string, std::string>& scriptParams,
                       const std::vector<std::string>& envVars)
    : pid_(-1), scriptWorkingDir_(scriptWorkingDir), relativeFilePath_(relativeFilePath), maxExecutionTime_(11)
{
    createArgv(scriptParams);
    createEnvp(envVars);
    pipefd_[0] = pipefd_[1] = -1;
}
CgiProcess::~CgiProcess() {
    cleanupArgv();
    cleanupEnvp();
    if (pipefd_[0] != -1) close(pipefd_[0]);
    if (pipefd_[1] != -1) close(pipefd_[1]);
    if (pid_ > 0) waitpid(pid_, NULL, WNOHANG);
}

bool CgiProcess::start() {
    std::cout << "CgiProcess::start : path absolu repertoire : " << scriptWorkingDir_ << " path relatif fichier : " << relativeFilePath_ << std::endl;

    if (pipe(pipefd_) == -1) {
        std::cerr << "pipe failed: " << strerror(errno) << std::endl;
        return false;
    }

    // Rendre le descripteur de lecture non bloquant
    if (fcntl(pipefd_[0], F_SETFL, O_NONBLOCK) == -1) {
        std::cerr << "fcntl failed: " << strerror(errno) << std::endl;
        return false;
    }

    pid_ = fork();
    if (pid_ == -1) {
        std::cerr << "fork failed: " << strerror(errno) << std::endl;
        return false;
    }

    if (pid_ == 0) {
        // Processus enfant

        // Fermer le descripteur de lecture inutilisé
        close(pipefd_[0]);

        // Rediriger la sortie standard vers le descripteur d'écriture du pipe
        dup2(pipefd_[1], STDOUT_FILENO);
        close(pipefd_[1]);

        // Changer le répertoire de travail vers 'scriptWorkingDir_'
        if (chdir(scriptWorkingDir_.c_str()) == -1) {
            std::cerr << "chdir failed: " << strerror(errno) << std::endl;
            _exit(1);
        }

        // Exécuter le script Python avec les arguments et l'environnement
        std::cerr << CYAN << "before execve from child" << RESET << std::endl;

        if (execve(args_[0], &args_[0], &envp_[0]) == -1) {
            std::cerr << "execve failed: " << strerror(errno) << std::endl;
            _exit(1);
        }
    }

    // Processus parent

    // Fermer le descripteur d'écriture inutilisé
    close(pipefd_[1]);
    startTime_ = time(NULL);
    return true;
}

bool CgiProcess::isRunning() const {
    std::cout << RED << "CgiProcess::isRunning" << std::endl;//debug
    int status;
    pid_t result = waitpid(pid_, &status, WNOHANG);
    if (result == 0) {
        // Le processus est toujours en cours d'exécution
        time_t currentTime = time(NULL);
        if (difftime(currentTime, startTime_) > maxExecutionTime_) {
            // Le processus a dépassé le temps maximal autorisé
            kill(pid_, SIGKILL); // Terminer le processus CGI
            std::cerr << "CGI process terminated due to timeout." << std::endl;
            return false;
        }
        return true;
    } else {
        // Le processus est terminé
        return false;
    }
}

int CgiProcess::getPipeFd() const {
    return pipefd_[0];
}

std::string CgiProcess::readOutput() {
    char buffer[4096];
    ssize_t bytesRead = read(pipefd_[0], buffer, sizeof(buffer));
    if (bytesRead > 0) {
        return std::string(buffer, bytesRead);
    }
    return "";
}

void CgiProcess::createEnvp(const std::vector<std::string>& envVars) {
    // Stocker les chaînes d'environnement pour assurer leur durée de vie
    for (size_t i = 0; i < envVars.size(); ++i) {
        envStrings_.push_back(envVars[i]);
        envp_.push_back(const_cast<char*>(envStrings_.back().c_str()));
    }
    envp_.push_back(NULL);
}

void CgiProcess::cleanupEnvp() {
    envp_.clear();
    envStrings_.clear();
}


void CgiProcess::createArgv(const std::map<std::string, std::string>& scriptParams) {
    // Chemin vers l'interpréteur Python
    std::string pythonInterpreter = "/usr/bin/python3";
    argStrings_.push_back(pythonInterpreter);
    args_.push_back(const_cast<char*>(argStrings_.back().c_str()));

    // Chemin relatif vers le script Python
    argStrings_.push_back(relativeFilePath_);
    args_.push_back(const_cast<char*>(argStrings_.back().c_str()));

    // Ajouter les paramètres du script en tant qu'arguments
    for (std::map<std::string, std::string>::const_iterator it = scriptParams.begin(); it != scriptParams.end(); ++it) {
        // Format des arguments : --key=value
        std::string arg = "--" + it->first + "=" + it->second;
        paramDecode(arg);
        argStrings_.push_back(arg);
        args_.push_back(const_cast<char*>(argStrings_.back().c_str()));
    }

    // Terminer le tableau d'arguments avec NULL
    args_.push_back(NULL);
}

void CgiProcess::cleanupArgv() {
    args_.clear();
    argStrings_.clear();
}

// Fonction pour décoder les caractères encodés au format %hexa dans la query string 
void CgiProcess::paramDecode(std::string& param) const {
    std::string decoded;
    char hex[3];
    hex[2] = '\0';
    for (std::string::size_type i = 0; i < param.length(); ++i) {
        if (param[i] == '%') {
            if (i + 2 < param.length()) {
                hex[0] = param[i + 1];
                hex[1] = param[i + 2];
                decoded += static_cast<char>(std::strtol(hex, NULL, 16));
                i += 2;
            }
        } else if (param[i] == '+') {
            decoded += ' ';
        } else {
            decoded += param[i];
        }
    }
    param = decoded;
}// DataSocket.cpp
#include "DataSocket.hpp"
#include "RequestHandler.hpp"
#include "Color_Macros.hpp"
#include <unistd.h>
#include <iostream>
#include <errno.h>//debug
#include <cstring>//debug

DataSocket::DataSocket(int fd, const std::vector<Server*>& servers, const Config& config)
    : client_fd_(fd), associatedServers_(servers), requestComplete_(false), config_(config),
      sendBufferOffset_(0), cgiProcess_(NULL), cgiPipeFd_(-1), cgiComplete_(true) {
}

DataSocket::~DataSocket() {
    closeSocket();
    if (cgiProcess_) {
        delete cgiProcess_;
        cgiProcess_ = NULL;
    }
}

bool DataSocket::receiveData() {
    char buffer[4096];
    ssize_t bytesRead = recv(client_fd_, buffer, sizeof(buffer), 0);

    if (bytesRead > 0) {
        std::string data(buffer, bytesRead);
        httpRequest_.appendData(data);

        if (httpRequest_.parseRequest()) {
            requestComplete_ = httpRequest_.isComplete();
        }
        return true;
    } else if (bytesRead == 0) {
        return false;
    } else {
        return false;
    }
}

bool DataSocket::isRequestComplete() const {
    return requestComplete_;
}

void DataSocket::processRequest() {
    RequestHandler handler(config_, associatedServers_);
    RequestResult result = handler.handleRequest(httpRequest_);

    if (result.responseReady) {
        sendBuffer_ = result.response.generateResponse();
        sendBufferOffset_ = 0;
    } else if (result.cgiProcess) {
        cgiProcess_ = result.cgiProcess;
        cgiPipeFd_ = cgiProcess_->getPipeFd();
        // std::cout << GREEN <<"DataSocket::processRequest result.cgiprocess : " << cgiPipeFd_ << RESET <<std::endl;//test
        cgiComplete_ = false;
    } else {
        sendBuffer_ = result.response.generateResponse();
        sendBufferOffset_ = 0;
    }

    httpRequest_.reset();
    requestComplete_ = false;
}

bool DataSocket::sendData() {
    // std::cout << "DataSocket::sendData" <<std::endl;//test
    if (sendBuffer_.empty()) {
        return true;
    }

    // Imprimer le contenu de sendBuffer_ qui sera envoyé
    // std::cout << YELLOW << sendBuffer_.substr(sendBufferOffset_) << RESET << std::endl;//debug test
    std::cout << YELLOW <<  "send data"<< RESET << std::endl;//debug test
    ssize_t bytesSent = send(client_fd_, sendBuffer_.c_str() + sendBufferOffset_, sendBuffer_.size() - sendBufferOffset_, 0);
    if (bytesSent > 0) {
        sendBufferOffset_ += bytesSent;
        if (sendBufferOffset_ >= sendBuffer_.size()) {
            sendBuffer_.clear();
            sendBufferOffset_ = 0;
            return true;
        }
    } else if (bytesSent == 0) {
        return false;
    } else {
        return false;
    }

    return true;
}

bool DataSocket::hasDataToSend() const {
    return !sendBuffer_.empty();
}

void DataSocket::closeSocket() {
    if (client_fd_ != -1) {
        close(client_fd_);
        client_fd_ = -1;
        std::cout << RED <<"DataSocket::closeSocket: Socket closed."<< RESET << std::endl;
    }
}

int DataSocket::getSocket() const {
    return client_fd_;
}

// CGI handling methods
bool DataSocket::hasCgiProcess() const {
    return cgiProcess_ != NULL;
}

int DataSocket::getCgiPipeFd() const {
    return cgiPipeFd_;
}

bool DataSocket::isCgiComplete() const {
    return cgiComplete_;
}

void DataSocket::readFromCgiPipe() {
    std::cout << RED << "DataSocket::readFromCgiPipe()" << RESET << std::endl; // Debug
    
    char buffer[4096];
    ssize_t bytesRead = read(cgiPipeFd_, buffer, sizeof(buffer));

    if (bytesRead > 0) {
        cgiOutputBuffer_.append(buffer, bytesRead);
        std::cout << BLUE << "CGI added buffer: " << std::string(buffer, bytesRead) << RESET << std::endl; // Debug
    } else if (bytesRead == 0) {
        // EOF atteint, le processus CGI a terminé
        closeCgiPipe();

        HttpResponse response;
        response.setStatusCode(200);
        response.setBody(cgiOutputBuffer_);
        response.setHeader("Content-Type", "text/html; charset=UTF-8");
        sendBuffer_ = response.generateResponse();
        sendBufferOffset_ = 0;
        cgiOutputBuffer_.clear();
    } else {
        // bytesRead < 0, une erreur s'est produite
        if (!cgiProcess_->isRunning()) {
                // Le processus CGI s'est terminé sans envoyer EOF
                std::cerr << "CGI process terminated without sending EOF." << std::endl;
                closeCgiPipe();

                HttpResponse response;
                response.setStatusCode(500);
                response.setBody("Internal Server Error");
                response.setHeader("Content-Type", "text/html; charset=UTF-8");
                sendBuffer_ = response.generateResponse();
                sendBufferOffset_ = 0;
                cgiOutputBuffer_.clear();
            }
    }
}

void DataSocket::closeCgiPipe() {
    if (cgiPipeFd_ != -1) {
        close(cgiPipeFd_);
        cgiPipeFd_ = -1;
    }
    if (cgiProcess_) {
        delete cgiProcess_;
        cgiProcess_ = NULL;
    }
    cgiComplete_ = true;
}
// WebServer.cpp
#include "WebServer.hpp"
#include <iostream>
#include <stdexcept>
#include <unistd.h>

WebServer::WebServer() : config_(NULL) {}

WebServer::~WebServer() {
    cleanUp();
    if (config_ != NULL) {
        delete config_;
        config_ = NULL;
    }
}

void WebServer::loadConfiguration(const std::string& configFile) {
    try {
        ConfigParser parser(configFile);
        config_ = parser.parse();
        config_->displayConfig();//debug
    } catch (const ParsingException &e) {
        throw (e);
    }
}

void WebServer::start() {
    if (config_ == NULL) {
        throw std::runtime_error("Configuration not loaded.");
    }

    const std::vector<Server*>& servers = config_->getServers();
    listeningHandler_.initialize(servers);
    std::cout << "Server started with " << servers.size() << " servers." << std::endl;
}

void WebServer::runEventLoop() {
    std::cout << "WebServer::runEventLoop(): Démarrage de la boucle d'événements." << std::endl;

    while (true) {
        std::vector<struct pollfd> pollfds;
        std::vector<ListeningSocket*> pollListeningSockets;
        std::vector<DataSocket*> pollDataSockets;
        std::vector<int> pollFdTypes; // 0: ListeningSocket, 1: ClientSocket, 2: CgiPipe

        // Ajouter les sockets d'écoute
        const std::vector<ListeningSocket*>& listeningSockets = listeningHandler_.getListeningSockets();
        size_t i;
        for (i = 0; i < listeningSockets.size(); ++i) {
            struct pollfd pfd;
            pfd.fd = listeningSockets[i]->getSocket();
            pfd.events = POLLIN;
            pfd.revents = 0;
            pollfds.push_back(pfd);
            pollListeningSockets.push_back(listeningSockets[i]);
            pollDataSockets.push_back(NULL); // Pas de DataSocket pour les ListeningSocket
            pollFdTypes.push_back(0); // ListeningSocket
        }

        // Ajouter les sockets de données
        const std::vector<DataSocket*>& dataSockets = dataHandler_.getClientSockets();
        for (i = 0; i < dataSockets.size(); ++i) {
            DataSocket* dataSocket = dataSockets[i];

            // Socket client
            struct pollfd pfd;
            pfd.fd = dataSocket->getSocket();
            pfd.events = POLLIN;
            if (dataSocket->hasDataToSend()) {
                pfd.events |= POLLOUT;
            }
            pfd.revents = 0;
            pollfds.push_back(pfd);
            pollListeningSockets.push_back(NULL); // Pas de ListeningSocket pour les DataSocket
            pollDataSockets.push_back(dataSocket);
            pollFdTypes.push_back(1); // ClientSocket

            // Pipe CGI (si présent)
            if (dataSocket->hasCgiProcess() && !dataSocket->isCgiComplete()) {
                struct pollfd cgiPfd;
                cgiPfd.fd = dataSocket->getCgiPipeFd();
                // std::cout << "add pipe to Poll : "<< cgiPfd.fd << std::endl;//test
                cgiPfd.events = POLLIN;
                cgiPfd.revents = 0;
                pollfds.push_back(cgiPfd);
                pollListeningSockets.push_back(NULL);
                pollDataSockets.push_back(dataSocket);
                pollFdTypes.push_back(2); // CgiPipe
            }
        }

        // Appel à poll()
        int ret = poll(&pollfds[0], pollfds.size(), -1);
        if (ret < 0) {
            // perror("poll");
            break;
        }

        // Traitement des événements
        for (i = 0; i < pollfds.size(); ++i) {
            if (pollfds[i].revents == 0)
                continue;

            if (pollFdTypes[i] == 0) {
                // Socket d'écoute
                if (pollfds[i].revents & POLLIN) {
                    ListeningSocket* listeningSocket = pollListeningSockets[i];
                    int new_fd = listeningSocket->acceptConnection();
                    if (new_fd >= 0) {
                        DataSocket* newDataSocket = new DataSocket(new_fd, listeningSocket->getAssociatedServers(), *config_);
                        dataHandler_.addClientSocket(newDataSocket);
                    }
                }
            } else if (pollFdTypes[i] == 1) {
                // Socket client
                DataSocket* dataSocket = pollDataSockets[i];
                if (pollfds[i].revents & POLLIN) {
                    if (!dataSocket->receiveData()) {
                        dataSocket->closeSocket();
                    } else if (dataSocket->isRequestComplete()) {
                        dataSocket->processRequest();
                    }
                }
                if (pollfds[i].revents & POLLOUT) {
                    if (!dataSocket->sendData()) {
                        dataSocket->closeSocket();
                    }
                }
                if (pollfds[i].revents & (POLLHUP | POLLERR | POLLNVAL)) {
                    dataSocket->closeSocket();
                }
            } else if (pollFdTypes[i] == 2) {
                // Pipe CGI
                DataSocket* dataSocket = pollDataSockets[i];
                if (pollfds[i].revents & POLLIN) {
                    std::cout << GREEN<< "CGI POLLIN EVENT" << RESET <<std::endl;//test
                    dataSocket->readFromCgiPipe();
                }
                else if (pollfds[i].revents & (POLLHUP)) {
                    std::cout<< GREEN << "CGI POLLHUP EVENT"<< RESET <<std::endl;//test
                    dataSocket->readFromCgiPipe();
                    dataSocket->closeCgiPipe();
                }
                else if (pollfds[i].revents & (POLLERR | POLLNVAL)) {
                    dataSocket->closeCgiPipe();
                }
            }
        }

        // Nettoyage des sockets fermées
        dataHandler_.removeClosedSockets();
    }
}

void WebServer::cleanUp() {
    listeningHandler_.cleanUp();
    dataHandler_.cleanUp();
}
