// WebServer.cpp
#include "WebServer.hpp"
#include <iostream>
#include <stdexcept>
#include <unistd.h>

WebServer::WebServer() : config_(NULL) {}

WebServer::~WebServer() {
    cleanUp();
    if (config_ != NULL) {
        delete config_;
        config_ = NULL;
    }
}

void WebServer::loadConfiguration(const std::string& configFile) {
    try {
        ConfigParser parser(configFile);
        config_ = parser.parse();
        config_->displayConfig();//debug
    } catch (const ParsingException &e) {
        throw (e);
    }
}

void WebServer::start() {
    if (config_ == NULL) {
        throw std::runtime_error("Configuration not loaded.");
    }

    const std::vector<Server*>& servers = config_->getServers();
    listeningHandler_.initialize(servers);
    std::cout << "Server started with " << servers.size() << " servers." << std::endl;
}

void WebServer::runEventLoop() {
    std::cout << "WebServer::runEventLoop(): Démarrage de la boucle d'événements." << std::endl;

    while (true) {
        std::vector<struct pollfd> pollfds;
        std::vector<ListeningSocket*> pollListeningSockets;
        std::vector<DataSocket*> pollDataSockets;
        std::vector<int> pollFdTypes; // 0: ListeningSocket, 1: ClientSocket, 2: CgiPipe

        // Ajouter les sockets d'écoute
        const std::vector<ListeningSocket*>& listeningSockets = listeningHandler_.getListeningSockets();
        size_t i;
        for (i = 0; i < listeningSockets.size(); ++i) {
            struct pollfd pfd;
            pfd.fd = listeningSockets[i]->getSocket();
            pfd.events = POLLIN;
            pfd.revents = 0;
            pollfds.push_back(pfd);
            pollListeningSockets.push_back(listeningSockets[i]);
            pollDataSockets.push_back(NULL); // Pas de DataSocket pour les ListeningSocket
            pollFdTypes.push_back(0); // ListeningSocket
        }

        // Ajouter les sockets de données
        const std::vector<DataSocket*>& dataSockets = dataHandler_.getClientSockets();
        for (i = 0; i < dataSockets.size(); ++i) {
            DataSocket* dataSocket = dataSockets[i];

            // Socket client
            struct pollfd pfd;
            pfd.fd = dataSocket->getSocket();
            pfd.events = POLLIN;
            if (dataSocket->hasDataToSend()) {
                pfd.events |= POLLOUT;
            }
            pfd.revents = 0;
            pollfds.push_back(pfd);
            pollListeningSockets.push_back(NULL); // Pas de ListeningSocket pour les DataSocket
            pollDataSockets.push_back(dataSocket);
            pollFdTypes.push_back(1); // ClientSocket

            // Pipe CGI (si présent)
            if (dataSocket->hasCgiProcess() && !dataSocket->isCgiComplete()) {
                struct pollfd cgiPfd;
                cgiPfd.fd = dataSocket->getCgiPipeFd();
                // std::cout << "add pipe to Poll : "<< cgiPfd.fd << std::endl;//test
                cgiPfd.events = POLLIN;
                cgiPfd.revents = 0;
                pollfds.push_back(cgiPfd);
                pollListeningSockets.push_back(NULL);
                pollDataSockets.push_back(dataSocket);
                pollFdTypes.push_back(2); // CgiPipe
            }
        }

        // Appel à poll()
        int timeout = 5000; // Temps ms avant de sortir de l' etat de poll
        int ret = poll(&pollfds[0], pollfds.size(), timeout);
        if (ret < 0) {
            // perror("poll");
            break;
        }

        checkCgiTimeouts();//verif si les timeouts ce sont declenches avant d' entrer dans poll

        // Traitement des événements
        for (i = 0; i < pollfds.size(); ++i) {
            if (pollfds[i].revents == 0)
                continue;

            if (pollFdTypes[i] == 0) {
                // Socket d'écoute
                if (pollfds[i].revents & POLLIN) {
                    ListeningSocket* listeningSocket = pollListeningSockets[i];
                    int new_fd = listeningSocket->acceptConnection();
                    if (new_fd >= 0) {
                        DataSocket* newDataSocket = new DataSocket(new_fd, listeningSocket->getAssociatedServers(), *config_);
                        dataHandler_.addClientSocket(newDataSocket);
                    }
                }
            } else if (pollFdTypes[i] == 1) {
                // Socket client
                DataSocket* dataSocket = pollDataSockets[i];
                if (pollfds[i].revents & POLLIN) {
                    if (!dataSocket->receiveData()) {
                        dataSocket->closeSocket();
                    } else if (dataSocket->isRequestComplete()) {
                        dataSocket->processRequest();
                        if (dataSocket->hasCgiProcess()) {
                            activeCgiSockets_.push_back(dataSocket);
                        }
                    }
                }
                if (pollfds[i].revents & POLLOUT) {
                    if (!dataSocket->sendData()) {
                        dataSocket->closeSocket();
                    }
                }
                if (pollfds[i].revents & (POLLHUP | POLLERR | POLLNVAL)) {
                    dataSocket->closeSocket();
                }
            } else if (pollFdTypes[i] == 2) {
                // Pipe CGI
                DataSocket* dataSocket = pollDataSockets[i];
                if (pollfds[i].revents & POLLIN) {
                    std::cout << GREEN<< "CGI POLLIN EVENT" << RESET <<std::endl;//test
                    dataSocket->readFromCgiPipe();
                }
                else if (pollfds[i].revents & (POLLHUP)) {
                    std::cout<< GREEN << "CGI POLLHUP EVENT"<< RESET <<std::endl;//test
                    dataSocket->readFromCgiPipe();
                    dataSocket->closeCgiPipe();
                }
                else if (pollfds[i].revents & (POLLERR | POLLNVAL)) {
                    dataSocket->closeCgiPipe();
                }
            }
        }

        // Nettoyage des sockets fermées attention ne pas reactiver a moins d' avoir modifie la logique de fermeture car  les sockets sont deja fermes avant donc cela genere des problemes
        // dataHandler_.removeClosedSockets();
    }
}

void WebServer::checkCgiTimeouts() {
    std::vector<DataSocket*>::iterator it = activeCgiSockets_.begin();
    while (it != activeCgiSockets_.end()) {
        DataSocket* dataSocket = *it;
        std::cout << "WebServer::checkCgiTimeouts" << std::endl; // le programme n' arrive jamais ici
        if (dataSocket->hasCgiProcess()) {
            if (!dataSocket->cgiProcessIsRunning()) {
                // Le processus CGI n'est plus en cours d'exécution
                it = activeCgiSockets_.erase(it);
            } else if (dataSocket->cgiProcessHasTimedOut()) {
                // Le processus CGI a dépassé le délai maximal
                dataSocket->terminateCgiProcess();
                it = activeCgiSockets_.erase(it);
            } else {
                ++it;
            }
        } else {
            // Le DataSocket n'a plus de processus CGI
            it = activeCgiSockets_.erase(it);
        }
    }
}

// void WebServer::runEventLoop() {
//     std::cout << "WebServer::runEventLoop(): Démarrage de la boucle d'événements." << std::endl;

//     while (true) {
//         std::vector<struct pollfd> pollfds;
//         std::vector<ListeningSocket*> pollListeningSockets;
//         std::vector<DataSocket*> pollDataSockets;
//         std::vector<int> pollFdTypes; // 0: ListeningSocket, 1: ClientSocket, 2: CgiPipe

//         // Ajouter les sockets d'écoute
//         const std::vector<ListeningSocket*>& listeningSockets = listeningHandler_.getListeningSockets();
//         size_t i;
//         for (i = 0; i < listeningSockets.size(); ++i) {
//             struct pollfd pfd;
//             pfd.fd = listeningSockets[i]->getSocket();
//             pfd.events = POLLIN;
//             pfd.revents = 0;
//             pollfds.push_back(pfd);
//             pollListeningSockets.push_back(listeningSockets[i]);
//             pollDataSockets.push_back(NULL); // Pas de DataSocket pour les ListeningSocket
//             pollFdTypes.push_back(0); // ListeningSocket
//         }

//         // Ajouter les sockets de données
//         const std::vector<DataSocket*>& dataSockets = dataHandler_.getClientSockets();
//         for (i = 0; i < dataSockets.size(); ++i) {
//             DataSocket* dataSocket = dataSockets[i];

//             // Socket client
//             struct pollfd pfd;
//             pfd.fd = dataSocket->getSocket();
//             pfd.events = 0;

//             if (dataSocket->getState() == SOCKET_ERROR_TIMEOUT) {
//                 // La socket a une erreur de timeout, il faut envoyer la réponse 504
//                 if (dataSocket->hasDataToSend()) {
//                     pfd.events |= POLLOUT;
//                 }
//             } else {
//                 pfd.events |= POLLIN;
//                 if (dataSocket->hasDataToSend()) {
//                     pfd.events |= POLLOUT;
//                 }
//             }

//             pfd.revents = 0;
//             pollfds.push_back(pfd);
//             pollListeningSockets.push_back(NULL); // Pas de ListeningSocket pour les DataSocket
//             pollDataSockets.push_back(dataSocket);
//             pollFdTypes.push_back(1); // ClientSocket

//             // Pipe CGI (si présent)
//             if (dataSocket->hasCgiProcess() && !dataSocket->isCgiComplete()) {
//                 struct pollfd cgiPfd;
//                 cgiPfd.fd = dataSocket->getCgiPipeFd();
//                 cgiPfd.events = POLLIN;
//                 cgiPfd.revents = 0;
//                 pollfds.push_back(cgiPfd);
//                 pollListeningSockets.push_back(NULL);
//                 pollDataSockets.push_back(dataSocket);
//                 pollFdTypes.push_back(2); // CgiPipe
//             }
//         }

//         // Appel à poll()
//         int ret = poll(&pollfds[0], pollfds.size(), 1000); // Timeout de 1000 ms
//         if (ret < 0) {
//             // perror("poll");
//             break;
//         }

//         // Traitement des événements
//         for (i = 0; i < pollfds.size(); ++i) {
//             if (pollfds[i].revents == 0)
//                 continue;

//             if (pollFdTypes[i] == 0) {
//                 // Socket d'écoute
//                 if (pollfds[i].revents & POLLIN) {
//                     ListeningSocket* listeningSocket = pollListeningSockets[i];
//                     int new_fd = listeningSocket->acceptConnection();
//                     if (new_fd >= 0) {
//                         DataSocket* newDataSocket = new DataSocket(new_fd, listeningSocket->getAssociatedServers(), *config_);
//                         dataHandler_.addClientSocket(newDataSocket);
//                     }
//                 }
//             } else if (pollFdTypes[i] == 1) {
//                 // Socket client
//                 DataSocket* dataSocket = pollDataSockets[i];
//                 if (dataSocket->getState() == SOCKET_ERROR_TIMEOUT) {
//                     if (pollfds[i].revents & POLLOUT) {
//                         if (!dataSocket->sendData()) {
//                             dataSocket->closeSocket();
//                         }
//                     }
//                     if (pollfds[i].revents & (POLLHUP | POLLERR | POLLNVAL)) {
//                         dataSocket->closeSocket();
//                     }
//                 } else {
//                     if (pollfds[i].revents & POLLIN) {
//                         if (!dataSocket->receiveData()) {
//                             dataSocket->closeSocket();
//                         } else if (dataSocket->isRequestComplete()) {
//                             dataSocket->processRequest();
//                         }
//                     }
//                     if (pollfds[i].revents & POLLOUT) {
//                         if (!dataSocket->sendData()) {
//                             dataSocket->closeSocket();
//                         }
//                     }
//                     if (pollfds[i].revents & (POLLHUP | POLLERR | POLLNVAL)) {
//                         dataSocket->closeSocket();
//                     }
//                 }
//             } else if (pollFdTypes[i] == 2) {
//                 // Pipe CGI
//                 DataSocket* dataSocket = pollDataSockets[i];
//                 if (pollfds[i].revents & POLLIN) {
//                     std::cout << GREEN<< "CGI POLLIN EVENT" << RESET <<std::endl;//test
//                     dataSocket->readFromCgiPipe();
//                 }
//                 else if (pollfds[i].revents & (POLLHUP)) {
//                     std::cout<< GREEN << "CGI POLLHUP EVENT"<< RESET <<std::endl;//test
//                     dataSocket->readFromCgiPipe();
//                     dataSocket->closeCgiPipe();
//                 }
//                 else if (pollfds[i].revents & (POLLERR | POLLNVAL)) {
//                     dataSocket->closeCgiPipe();
//                 }
//             }
//         }

//         // Vérifier les timeouts des DataSocket
//         const std::vector<DataSocket*>& allDataSockets = dataHandler_.getClientSockets();
//         for (size_t j = 0; j < allDataSockets.size(); ++j) {
//             DataSocket* dataSocket = allDataSockets[j];
//             if (dataSocket->hasTimedOut()) {
//                 if (dataSocket->getState() != SOCKET_ERROR_TIMEOUT) {
//                     std::cerr << "DataSocket timed out, sending 504 Gateway Timeout." << std::endl;
//                     dataSocket->handleTimeout();
//                 }
//             }
//         }

//         // Nettoyage des sockets fermées
//         dataHandler_.removeClosedSockets();
//     }
// }

void WebServer::cleanUp() {
    listeningHandler_.cleanUp();
    dataHandler_.cleanUp();
}
// DataSocket.cpp
#include "DataSocket.hpp"
#include "RequestHandler.hpp"
#include "Color_Macros.hpp"
#include "Error.hpp"
#include <unistd.h>
#include <iostream>
#include <errno.h>//debug
#include <cstring>//debug

DataSocket::DataSocket(int fd, const std::vector<Server*>& servers, const Config& config)
    : client_fd_(fd), associatedServers_(servers), requestComplete_(false), config_(config),
      sendBufferOffset_(0), cgiProcess_(NULL), cgiPipeFd_(-1), cgiComplete_(true) {
}

DataSocket::~DataSocket() {
    closeSocket();
    if (cgiProcess_) {
        delete cgiProcess_;
        cgiProcess_ = NULL;
    }
}

bool DataSocket::receiveData() {
    char buffer[4096];
    ssize_t bytesRead = recv(client_fd_, buffer, sizeof(buffer), 0);

    if (bytesRead > 0) {
        std::string data(buffer, bytesRead);
        httpRequest_.appendData(data);

        if (httpRequest_.parseRequest()) {
            if (httpRequest_.hasParseError()) {
                // Une erreur de parsing a été détectée
                handleParseError(httpRequest_.getParseErrorCode());
                return false; // Fermer la connexion après avoir envoyé l'erreur
            }
            requestComplete_ = httpRequest_.isComplete();
        } else {
            if (httpRequest_.hasParseError()) {
                // Une erreur de parsing a été détectée
                handleParseError(httpRequest_.getParseErrorCode());
                return false; // Fermer la connexion après avoir envoyé l'erreur
            }
        }
        return true;
    } else if (bytesRead == 0) {
        return false;
    } else {
        return false;
    }
}

void DataSocket::handleParseError(int errorCode) {
    
    std::cerr << "DataSocket::handleParseError: Detected parse error code " << errorCode << std::endl;
    RequestResult result;
    // Trouver le serveur associé pour obtenir la page d'erreur
    const Server* server = getAssociatedServer();
    if (server) {
        result.response = handleError(errorCode, server->getErrorPageFullPath(errorCode)); // nullptr pour location
        sendBuffer_ = result.response.generateResponse();
        sendBufferOffset_ = 0;
        result.responseReady = true;
    } else {
        // Si aucun serveur associé, envoyer une réponse d'erreur par défaut
        result.response = handleError(errorCode, config_.getErrorPageFullPath(errorCode)); // nullptr pour location
        sendBuffer_ = result.response.generateResponse();
        sendBufferOffset_ = 0;
        result.responseReady = true;
    }
}

const Server* DataSocket::getAssociatedServer() const {
    // Implémentez cette méthode pour retourner le serveur associé à cette DataSocket
    // Cela dépend de votre architecture, mais souvent vous pouvez obtenir le serveur à partir des associations
    // passées lors de la création de DataSocket dans WebServer::runEventLoop()
    if (!associatedServers_.empty()) {
        return associatedServers_[0]; // Exemple simplifié
    }
    return NULL;
}

bool DataSocket::isRequestComplete() const {
    return requestComplete_;
}

void DataSocket::processRequest() {
    RequestHandler handler(config_, associatedServers_);
    RequestResult result = handler.handleRequest(httpRequest_);

    if (result.responseReady) {
        sendBuffer_ = result.response.generateResponse();
        sendBufferOffset_ = 0;
    } else if (result.cgiProcess) {
        cgiProcess_ = result.cgiProcess;
        cgiPipeFd_ = cgiProcess_->getPipeFd();
        // std::cout << GREEN <<"DataSocket::processRequest result.cgiprocess : " << cgiPipeFd_ << RESET <<std::endl;//test
        cgiComplete_ = false;
    } else {
        sendBuffer_ = result.response.generateResponse();
        sendBufferOffset_ = 0;
    }

    httpRequest_.reset();
    requestComplete_ = false;
}

bool DataSocket::sendData() {
    // std::cout << "DataSocket::sendData" <<std::endl;//test
    if (sendBuffer_.empty()) {
        return true;
    }

    // Imprimer le contenu de sendBuffer_ qui sera envoyé
    // std::cout << YELLOW << sendBuffer_.substr(sendBufferOffset_) << RESET << std::endl;//debug test
    std::cout << YELLOW <<  "send data"<< RESET << std::endl;//debug test
    ssize_t bytesSent = send(client_fd_, sendBuffer_.c_str() + sendBufferOffset_, sendBuffer_.size() - sendBufferOffset_, 0);
    if (bytesSent > 0) {
        sendBufferOffset_ += bytesSent;
        if (sendBufferOffset_ >= sendBuffer_.size()) {
            sendBuffer_.clear();
            sendBufferOffset_ = 0;
            return true;
        }
    } else if (bytesSent == 0) {
        return false;
    } else {
        return false;
    }

    return true;
}

bool DataSocket::hasDataToSend() const {
    return !sendBuffer_.empty();
}

void DataSocket::closeSocket() {
    if (client_fd_ != -1) {
        close(client_fd_);
        client_fd_ = -1;
        std::cout << RED <<"DataSocket::closeSocket: Socket closed."<< RESET << std::endl;
    } else {
        std::cout <<RED << "Tentative de fermeture d'une socket déjà fermée." << RESET << std::endl;
    }
}

int DataSocket::getSocket() const {
    return client_fd_;
}

// CGI handling methods
bool DataSocket::hasCgiProcess() const {
    return cgiProcess_ != NULL;
}

int DataSocket::getCgiPipeFd() const {
    return cgiPipeFd_;
}

bool DataSocket::isCgiComplete() const {
    return cgiComplete_;
}

void DataSocket::readFromCgiPipe() {
    std::cout << RED << "DataSocket::readFromCgiPipe()" << RESET << std::endl; // Debug
    
    char buffer[4096];
    ssize_t bytesRead = read(cgiPipeFd_, buffer, sizeof(buffer));

    if (bytesRead > 0) {
        cgiOutputBuffer_.append(buffer, bytesRead);
        std::cout << BLUE << "CGI added buffer: " << std::string(buffer, bytesRead) << RESET << std::endl; // Debug
    } else if (bytesRead == 0) {
        // EOF atteint, le processus CGI a terminé
        closeCgiPipe();

        HttpResponse response;
        response.setStatusCode(200);
        response.setBody(cgiOutputBuffer_);
        response.setHeader("Content-Type", "text/html; charset=UTF-8");
        sendBuffer_ = response.generateResponse();
        sendBufferOffset_ = 0;
        cgiOutputBuffer_.clear();
    } else {
        // bytesRead < 0, une erreur s'est produite
        if (!cgiProcess_->isRunning()) {
                // Le processus CGI s'est terminé sans envoyer EOF
                std::cerr << "CGI process terminated without sending EOF." << std::endl;
                closeCgiPipe();

                HttpResponse response;
                response.setStatusCode(500);
                response.setBody("Internal Server Error");
                response.setHeader("Content-Type", "text/html; charset=UTF-8");
                sendBuffer_ = response.generateResponse();
                sendBufferOffset_ = 0;
                cgiOutputBuffer_.clear();
            }
    }
}

bool DataSocket::cgiProcessIsRunning() const {
    if (cgiProcess_) {
        return cgiProcess_->isRunning();
    }
    return false;
}

bool DataSocket::cgiProcessHasTimedOut() const {
    if (cgiProcess_) {
        return cgiProcess_->hasTimedOut();
    }
    return false;
}

void DataSocket::terminateCgiProcess() {
    if (cgiProcess_) {
        cgiProcess_->terminate();
        closeCgiPipe();
        // Envoyer une réponse d'erreur au client
        HttpResponse response = handleError(500, associatedServers_[0]->getErrorPageFullPath(500));//test
        // HttpResponse response;
        // response.setStatusCode(500);
        // response.setBody("Internal Server Error (CGI timeout)");
        // response.setHeader("Content-Type", "text/html; charset=UTF-8");
        sendBuffer_ = response.generateResponse();
        sendBufferOffset_ = 0;
        cgiOutputBuffer_.clear();
    }
}

void DataSocket::closeCgiPipe() {
    if (cgiPipeFd_ != -1) {
        close(cgiPipeFd_);
        cgiPipeFd_ = -1;
    }
    if (cgiProcess_) {
        delete cgiProcess_;
        cgiProcess_ = NULL;
    }
    cgiComplete_ = true;
}// RequestHandler.cpp
#include "RequestHandler.hpp"
#include <algorithm>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>
#include <fstream>
#include <sstream>
#include <iostream>
#include <limits.h>
#include "../includes/Utils.hpp"
#include "../includes/Error.hpp"
#include "../includes/Color_Macros.hpp"
#include <cerrno> // Pour errno
#include <string.h> // Pour errno


RequestHandler::RequestHandler(const Config& config, const std::vector<Server*>& associatedServers)
    : config_(config), associatedServers_(associatedServers)
{
}

RequestHandler::~RequestHandler() {}

RequestResult RequestHandler::handleRequest(const HttpRequest& request) {
    RequestResult result;
    const Server* server = selectServer(request);

    // Vérifier si le serveur est NULL
    if (!server) {
        result.response = handleError(400, config_.getErrorPageFullPath(400));
        result.responseReady = true;
        return result;
    }

    const Location* location = selectLocation(server, request);

    process(server, location, request, result);
    return result;
}

const Server* RequestHandler::selectServer(const HttpRequest& request) const {
    std::string hostHeader = request.getHeader("Host");
    if (hostHeader.empty()) {
        std::cerr << "No Host header found in the request." << std::endl;
        return NULL; // Retourner NULL pour indiquer une erreur
    }

    // Parcourir tous les serveurs pour trouver une correspondance
    for (size_t i = 0; i < associatedServers_.size(); ++i) {
        const std::vector<std::string>& serverNames = associatedServers_[i]->getServerNames();
        if (std::find(serverNames.begin(), serverNames.end(), hostHeader) != serverNames.end()) {
            std::cerr << "RequestHandler::selectServer   : Server found by name => first name of server : " << associatedServers_[i]->getServerNames()[0] << " ip:port : "<< associatedServers_[i]->getHost() << ":"<< associatedServers_[i]->getPort() << std::endl; //test
            return associatedServers_[i];
        }
    }

    // Si aucun serveur ne correspond, utiliser le premier serveur comme défaut
    if (!associatedServers_.empty()) {
        std::cerr << "RequestHandler::selectServer   : Default server Used => first name of server : " << associatedServers_[0]->getServerNames()[0] << " ip:port : "<< associatedServers_[0]->getHost() << ":"<< associatedServers_[0]->getPort() << std::endl;//test

        return associatedServers_[0];
    }

    std::cerr << "RequestHandler::selectServer   : No server found. Default server must exist." << std::endl;//test
    // Aucun serveur configuré
    return NULL;
}

const Location* RequestHandler::selectLocation(const Server* server, const HttpRequest& request) const {
    // Vérifier si le serveur est NULL
    if (!server) {
        return NULL;
    }

    std::string requestPath = request.getPath();
    const std::vector<Location>& locations = server->getLocations();

    const Location* matchedLocation = NULL;
    size_t longestMatch = 0;

    for (size_t i = 0; i < locations.size(); ++i) {
        std::string locPath = locations[i].getPath();
        if (requestPath.find(locPath) == 0 && locPath.length() > longestMatch) {
            matchedLocation = &locations[i];
            longestMatch = locPath.length();
        }
    }

    if (matchedLocation)
        std::cout << "Request Path: " << requestPath << " Matched location: " << matchedLocation->getPath() << std::endl; //test
    return matchedLocation;
}

void RequestHandler::process(const Server* server, const Location* location, const HttpRequest& request, RequestResult& result) const {
    // Vérifier si le serveur est NULL
    if (!server) {
        result.response = handleError(400, config_.getErrorPageFullPath(400));
        result.responseReady = true;
        return;
    }

    // Collecte des méthodes autorisées
    std::vector<std::string> allowedMethods;
    if (location && !location->getAllowedMethods().empty()) {
        allowedMethods = location->getAllowedMethods();
    } else {
        // Méthodes autorisées par défaut si non spécifiées
        allowedMethods.push_back("GET");
        allowedMethods.push_back("POST");
        allowedMethods.push_back("DELETE");
    }

    // Vérifier si la méthode HTTP est autorisée
    if (std::find(allowedMethods.begin(), allowedMethods.end(), request.getMethod()) == allowedMethods.end()) {
        // Méthode non autorisée
        std::string errorPagePath = getErrorPageFullPath(405, location, server);
        result.response = handleError(405, errorPagePath);
        // Ajouter l'en-tête Allow
        result.response.setHeader("Allow", join(allowedMethods, ", "));
        result.responseReady = true;
        return;
    }

    // Redirection
    if (location && !location->getRedirection().empty()) {
        std::string redirectionUrl = location->getRedirection();
        result.response.setStatusCode(302);
        result.response.setHeader("Location", redirectionUrl);
        result.response.setBody("Redirecting to " + redirectionUrl);
        result.responseReady = true;
        return;
    }

    // Gestion des CGI
    if (location && !location->getCgiExtension().empty() && location->getCGIEnable() && endsWith(request.getPath(), location->getCgiExtension())) {
        CgiProcess* cgiProcess = startCgiProcess(server, location, request);
        if (cgiProcess) {
            result.cgiProcess = cgiProcess;
            result.responseReady = false;
            return;
        } else {
            std::string errorPagePath = getErrorPageFullPath(500, location, server);
            result.response = handleError(500, errorPagePath);
            result.responseReady = true;
            return;
        }
    }

    // Gestion des fichiers statiques
    if (request.getMethod() == "GET") {
        result.response = serveStaticFile(server, location, request);
        result.responseReady = true;
        return;
    }

    // Gestion de l'upload de fichiers
    if (request.getMethod() == "POST" && location && location->getUploadEnable()) {
        result.response = handleFileUpload(request, location, server);
        result.responseReady = true;
        return;
    }

    // Si aucune condition précédente n'est satisfaite, retourner une erreur 405
    std::string errorPagePath = getErrorPageFullPath(405, location, server);
    result.response = handleError(405, errorPagePath);
    result.response.setHeader("Allow", join(allowedMethods, ", "));
    result.responseReady = true;
}

CgiProcess* RequestHandler::startCgiProcess(const Server* server, const Location* location , const HttpRequest& request) const {
    char cwd[PATH_MAX];

    if (getcwd(cwd, sizeof(cwd)) == NULL) {
        std::cerr << RED <<"RequestHandler::startCgiProcess : Error getcwd: " << strerror(errno) << RESET << std::endl;
        return NULL; // Retourner NULL pour indiquer une erreur
    }
    std::string scriptWorkingDir = cwd ;
    scriptWorkingDir += "/" ;
    scriptWorkingDir += server->getRoot();
    if (location){
        scriptWorkingDir += "/" ;
        scriptWorkingDir += location->getPath();
        scriptWorkingDir += "/";
    }
    std::string relativeFilePath = request.getPath();
    if (location && relativeFilePath.compare(0, location->getPath().length(), location->getPath()) == 0) {
        relativeFilePath.erase(0, location->getPath().length());
    }
    relativeFilePath = "./" + relativeFilePath;

    std::map<std::string, std::string> params;
    if (request.getMethod() == "GET") {
        // Extraire les paramètres de la query string
        params = createScriptParamsGET(request.getQueryString());
    } else if (request.getMethod() == "POST") {
        std::string contentType = request.getHeader("Content-Type");
        if (contentType == "application/x-www-form-urlencoded") {
            // Extraire les paramètres du corps de la requête
            params = createScriptParamsPOST(request.getBody());
        } else {
            // Gérer d'autres types de contenu ou renvoyer une erreur
            std::cerr << "Type de contenu non pris en charge pour POST: " << contentType << std::endl;
            return NULL;
        }
    } else {
        // Méthode non prise en charge
        std::cerr << "Méthode HTTP non prise en charge: " << request.getMethod() << std::endl;
        return NULL;
    }

    std::vector<std::string> envVars;
    setupScriptEnvp(request, relativeFilePath, envVars);

    // Créer l'objet CgiProcess avec les paramètres
    CgiProcess* cgiProcess = new CgiProcess(scriptWorkingDir, relativeFilePath, params, envVars);
    if (!cgiProcess->start()) {
        delete cgiProcess;
        return NULL;
    }
    return cgiProcess;
}

void RequestHandler::setupScriptEnvp(const HttpRequest& request, const std::string& relativeFilePath,  std::vector<std::string>& envVars) const{
    envVars.push_back("GATEWAY_INTERFACE=CGI/1.1");
    envVars.push_back("SERVER_PROTOCOL=HTTP/1.1");
    envVars.push_back("REQUEST_METHOD=" + request.getMethod());
    envVars.push_back("SCRIPT_FILENAME=" + relativeFilePath);
    envVars.push_back("CONTENT_TYPE=" + request.getHeader("Content-Type"));
    envVars.push_back("CONTENT_LENGTH=" + request.getHeader("Content-Length"));
    // envVars.push_back("QUERY_STRING=" + request.getQueryString());//inutile puisque deja envoyees dans les arguments
    
}


std::map<std::string, std::string> RequestHandler::createScriptParamsGET(const std::string& queryString) const {
    std::map<std::string, std::string> params;
    std::string::size_type last_pos = 0, amp_pos;

    while ((amp_pos = queryString.find('&', last_pos)) != std::string::npos) {
        std::string key_value_pair = queryString.substr(last_pos, amp_pos - last_pos);
        std::string::size_type eq_pos = key_value_pair.find('=');
        if (eq_pos != std::string::npos) {
            std::string key = key_value_pair.substr(0, eq_pos);
            std::string value = key_value_pair.substr(eq_pos + 1);
            params[key] = value;
        } else if (!key_value_pair.empty()) {
            // If there's no '=', treat the entire string as a key with an empty value
            params[key_value_pair] = "";
        }
        last_pos = amp_pos + 1;
    }

    // Handle the last parameter (or only parameter if no '&' was found)
    std::string key_value_pair = queryString.substr(last_pos);
    if (!key_value_pair.empty()) {
        std::string::size_type eq_pos = key_value_pair.find('=');
        if (eq_pos != std::string::npos) {
            std::string key = key_value_pair.substr(0, eq_pos);
            std::string value = key_value_pair.substr(eq_pos + 1);
            params[key] = value;
        } else {
            // If there's no '=', treat the entire string as a key with an empty value
            params[key_value_pair] = "";
        }
    }

    return params;
}

std::map<std::string, std::string> RequestHandler::createScriptParamsPOST(const std::string& postBody) const {
    std::map<std::string, std::string> params;
    std::string::size_type last_pos = 0, amp_pos;

    while ((amp_pos = postBody.find('&', last_pos)) != std::string::npos) {
        std::string key_value_pair = postBody.substr(last_pos, amp_pos - last_pos);
        std::string::size_type eq_pos = key_value_pair.find('=');
        if (eq_pos != std::string::npos) {
            std::string key = key_value_pair.substr(0, eq_pos);
            std::string value = key_value_pair.substr(eq_pos + 1);
            params[key] = value;
        } else if (!key_value_pair.empty()) {
            params[key_value_pair] = "";
        }
        last_pos = amp_pos + 1;
    }

    // Traiter le dernier paramètre
    std::string key_value_pair = postBody.substr(last_pos);
    if (!key_value_pair.empty()) {
        std::string::size_type eq_pos = key_value_pair.find('=');
        if (eq_pos != std::string::npos) {
            std::string key = key_value_pair.substr(0, eq_pos);
            std::string value = key_value_pair.substr(eq_pos + 1);
            params[key] = value;
        } else {
            params[key_value_pair] = "";
        }
    }

    return params;
}


HttpResponse RequestHandler::serveStaticFile(const Server* server, const Location* location, const HttpRequest& request) const {
    HttpResponse response;

    // Déterminer le répertoire racine et le fichier index
    std::string root = server->getRoot();
    std::string index = server->getIndex();

    if (location) {
        root = location->getRoot();
        index = location->getIndex();
    }

    // Construire le chemin complet du fichier demandé
    std::string requestPath = request.getPath();

    // Vérifier que requestPath n'est pas vide
    if (requestPath.empty()) {
        requestPath = "/";
    }

    // Gérer le cas où le chemin se termine par un '/'
    if (requestPath[requestPath.size() - 1] == '/') {
        if (location && !location->getIndexIsSet() && location->getAutoIndex()) {
            // Générer l'auto-index si l'index n'est pas défini et que l'auto-index est activé
            return generateAutoIndex(root + requestPath, requestPath);
        }
        // Ajouter le fichier index au chemin
        requestPath += index;
    }

    // Retirer le chemin de la location du requestPath si root est défini dans la location
    if (location && location->getRootIsSet()) {
        std::string to_remove = location->getPath();
        size_t pos = requestPath.find(to_remove);
        if (pos != std::string::npos) {
            requestPath.erase(pos, to_remove.length());
        }
    }

    // Construire le chemin complet vers le fichier
    std::string fullPath = root + requestPath;
    std::cout << "Serving file: " << fullPath << std::endl;

    // Vérifier la sécurité du chemin
    if (!isPathSecure(root, fullPath)) {
        std::string errorPagePath = getErrorPageFullPath(403, location, server);
        return handleError(403, errorPagePath);
    }

    // Vérifier si le fichier existe et est accessible
    struct stat fileStat;
    if (stat(fullPath.c_str(), &fileStat) != 0) {
        if (errno == EACCES) {
            std::string errorPagePath = getErrorPageFullPath(403, location, server);
            return handleError(403, errorPagePath); // Forbidden
        } else if (errno == ENOENT || errno == ENOTDIR) {
            std::string errorPagePath = getErrorPageFullPath(404, location, server);
            return handleError(404, errorPagePath); // Not Found
        } else {
            std::string errorPagePath = getErrorPageFullPath(500, location, server);
            return handleError(500, errorPagePath); // Internal Server Error
        }
    }

    // Vérifier que c'est un fichier régulier
    if (!S_ISREG(fileStat.st_mode)) {
        std::string errorPagePath = getErrorPageFullPath(403, location, server);
        return handleError(403, errorPagePath); // Forbidden
    }

    // Ouvrir le fichier demandé
    std::ifstream file(fullPath.c_str(), std::ios::in | std::ios::binary);
    if (!file.is_open()) {
        if (errno == EACCES) {
            std::string errorPagePath = getErrorPageFullPath(403, location, server);
            return handleError(403, errorPagePath); // Forbidden
        } else {
            std::string errorPagePath = getErrorPageFullPath(404, location, server);
            return handleError(404, errorPagePath); // Not Found
        }
    }

    // Lire le contenu du fichier
    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string fileContent = buffer.str();
    file.close();

    // Définir les en-têtes et le corps de la réponse
    response.setStatusCode(200);
    response.setBody(fileContent);

    // Définir le Content-Type en fonction de l'extension du fichier
    size_t dotPos = fullPath.find_last_of('.');
    if (dotPos != std::string::npos) {
        std::string extension = fullPath.substr(dotPos + 1);
        std::string contentType = getMimeType(extension);
        if (!contentType.empty()) {
            response.setHeader("Content-Type", contentType);
            response.setHeader("Connection", "close");
        }
    }

    return response;
}

// HttpResponse RequestHandler::serveStaticFile(const Server* server, const Location* location, const HttpRequest& request) const 
// {
//     HttpResponse response;

//     // Déterminer le répertoire racine et le fichier index
//     std::string root = server->getRoot();
//     std::string index = server->getIndex();

//     if (location) {
//         root = location->getRoot();
//         index = location->getIndex();
//     }

//     // Construire le chemin complet du fichier demandé
//     std::string requestPath = request.getPath();

//     // Vérifier que requestPath n'est pas vide
//     if (requestPath.empty()) {
//         requestPath = "/";
//     }

//     if (requestPath[requestPath.size() - 1] == '/')
//     {
//         if (location)//debug 
//             std::cout<< GREEN <<"location path: "<< location->getPath() <<"'" <<location->getIndexIsSet() << "'" << location->getAutoIndex()<< RESET << std::endl;//test
//         if (location && !location->getIndexIsSet() && location->getAutoIndex())
//             return(generateAutoIndex(root + requestPath, requestPath));
//         requestPath += index;
//     }
//     // Retirer la location de requestPath si la directive root est paramétrée en son sein 
//     if (location && location->getRootIsSet())
//     {
//         std::string to_remove = location->getPath();
//         size_t pos = requestPath.find(to_remove);
//         if (pos != std::string::npos) {
//             requestPath.erase(pos, to_remove.length());
//             // std::cout << "Location path removed" << to_remove << std::endl;//test
//         }
//     }

//     std::string fullPath = root + requestPath;
//     std::cout << "Serving file: " << fullPath << std::endl;

//     // Vérifier la sécurité du chemin
//     if (!isPathSecure(root, fullPath)) {
//         return handleError(403, &config_, server); // Forbidden
//     }

//     // Vérifier si le fichier existe et est accessible
//     struct stat fileStat;
//     if (stat(fullPath.c_str(), &fileStat) != 0) {
//         if (errno == EACCES) {
//             return handleError(403, &config_, server); // Forbidden
//         } else if (errno == ENOENT || errno == ENOTDIR) {
//             return handleError(404, &config_, server); // Not Found
//         } else {
//             return handleError(500, &config_, server); // Internal Server Error
//         }
//     }

//     // Vérifier que c'est un fichier régulier
//     if (!S_ISREG(fileStat.st_mode)) {
//         return handleError(403, &config_, server); // Forbidden
//     }

//     // Ouvrir le fichier demandé
//     std::ifstream file(fullPath.c_str(), std::ios::in | std::ios::binary);
//     if (!file.is_open()) {
//         if (errno == EACCES) {
//             return handleError(403, &config_, server); // Forbidden
//         } else {
//             return handleError(404, &config_, server); // Not Found
//         }
//     }

//     // Lire le contenu du fichier
//     std::stringstream buffer;
//     buffer << file.rdbuf();
//     std::string fileContent = buffer.str();
//     file.close();

//     // Définir les en-têtes et le corps de la réponse
//     response.setStatusCode(200);
//     response.setBody(fileContent);

//     // Définir le Content-Type en fonction de l'extension du fichier
//     size_t dotPos = fullPath.find_last_of('.');
//     if (dotPos != std::string::npos) {
//         std::string extension = fullPath.substr(dotPos + 1);
//         std::string contentType = getMimeType(extension);
//         if (!contentType.empty()) {
//             response.setHeader("Content-Type", contentType);
//         }
//     }

//     return response;
// }

HttpResponse RequestHandler::handleFileUpload(const HttpRequest& request, const Location* location, const Server* server) const {
    std::cout << RED << "RequestHandler::handleFileUpload" << RESET << std::endl; // Test
    HttpResponse response;

    // Vérifier que le Content-Type est multipart/form-data
    std::string contentType = request.getHeader("Content-Type");
    if (contentType.find("multipart/form-data") != 0) {
        std::string errorPagePath = getErrorPageFullPath(400, location, server);
        response = handleError(400, errorPagePath);
        return response;
    }

    // Extraire la limite (boundary) de l'en-tête Content-Type
    std::string boundaryPrefix = "boundary=";
    std::string::size_type boundaryPos = contentType.find(boundaryPrefix);
    if (boundaryPos == std::string::npos) {
        // Pas de boundary trouvé
        std::string errorPagePath = getErrorPageFullPath(400, location, server);
        response = handleError(400, errorPagePath);
        return response;
    }
    boundaryPos += boundaryPrefix.length();
    std::string boundary = "--" + contentType.substr(boundaryPos);

    // Lire le corps de la requête
    std::string body = request.getBody();

    // Vérifier que le répertoire d'upload existe
    std::string uploadDirectory = location->getUploadStore();  // Obtenir le répertoire d'upload depuis la configuration
    struct stat dirStat;
    if (stat(uploadDirectory.c_str(), &dirStat) != 0 || !S_ISDIR(dirStat.st_mode)) {
        std::cerr << "Upload directory does not exist: " << uploadDirectory << std::endl;
        std::string errorPagePath = getErrorPageFullPath(500, location, server);
        response = handleError(500, errorPagePath);
        return response;
    }

    // Séparer les différentes parties
    std::string::size_type start = 0;
    while ((start = body.find(boundary, start)) != std::string::npos) {
        start += boundary.length();
        std::string::size_type end = body.find(boundary, start);
        if (end == std::string::npos) break;

        std::string part = body.substr(start, end - start);

        // Extraire les en-têtes de la partie
        std::string::size_type headerEnd = part.find("\r\n\r\n");
        if (headerEnd == std::string::npos) continue;

        std::string headers = part.substr(0, headerEnd);
        std::string fileData = part.substr(headerEnd + 4);

        // Vérifier si cette partie est un fichier
        std::string filenamePrefix = "filename=\"";
        std::string::size_type filenamePos = headers.find(filenamePrefix);
        if (filenamePos != std::string::npos) {
            std::string::size_type filenameEndPos = headers.find("\"", filenamePos + filenamePrefix.length());
            if (filenameEndPos != std::string::npos) {
                std::string filename = headers.substr(filenamePos + filenamePrefix.length(), filenameEndPos - (filenamePos + filenamePrefix.length()));

                // Construire le chemin complet pour sauvegarder le fichier
                std::string fullPath = uploadDirectory + "/" + filename;

                // Sauvegarder le fichier
                std::ofstream file(fullPath.c_str(), std::ios::binary);
                if (file.is_open()) {
                    file.write(fileData.c_str(), fileData.size());
                    file.close();
                    std::cout << "File saved: " << fullPath << std::endl;
                } else {
                    std::cerr << "Failed to save file: " << fullPath << std::endl;
                    std::string errorPagePath = getErrorPageFullPath(500, location, server);
                    response = handleError(500, errorPagePath);
                    return response;
                }
            }
        }
    }

    response.setStatusCode(200);
    response.setBody("File upload successful.");
    return response;
}


// HttpResponse RequestHandler::handleFileUpload(const HttpRequest& request, const Location* location) const {
//     std::cout << RED << "RequestHandler::handleFileUpload" << RESET << std::endl;//test
//     HttpResponse response;

//     // Vérifier que le Content-Type est multipart/form-data
//     std::string contentType = request.getHeader("Content-Type");
//     if (contentType.find("multipart/form-data") != 0) {
//         response = handleError(400, &config_, location->);
//         return response;
//     }

//     // Extraire la limite (boundary) de l'en-tête Content-Type
//     std::string boundaryPrefix = "boundary=";
//     std::string::size_type boundaryPos = contentType.find(boundaryPrefix);
//     if (boundaryPos != std::string::npos) {
//         boundaryPos += boundaryPrefix.length();
//         std::string boundary = "--" + contentType.substr(boundaryPos);

//         // Lire le corps de la requête
//         std::string body = request.getBody();

//         // Séparer les différentes parties
//         std::string::size_type start = 0;
//         while ((start = body.find(boundary, start)) != std::string::npos) {
//             start += boundary.length();
//             std::string::size_type end = body.find(boundary, start);
//             if (end == std::string::npos) break;

//             std::string part = body.substr(start, end - start);

//             // Extraire les en-têtes de la partie
//             std::string::size_type headerEnd = part.find("\r\n\r\n");
//             if (headerEnd == std::string::npos) continue;

//             std::string headers = part.substr(0, headerEnd);
//             std::string fileData = part.substr(headerEnd + 4);

//             // Vérifier si cette partie est un fichier
//             std::string filenamePrefix = "filename=\"";
//             std::string::size_type filenamePos = headers.find(filenamePrefix);
//             if (filenamePos != std::string::npos) {
//                 std::string::size_type filenameEndPos = headers.find("\"", filenamePos + filenamePrefix.length());
//                 if (filenameEndPos != std::string::npos) {
//                     std::string filename = headers.substr(filenamePos + filenamePrefix.length(), filenameEndPos - (filenamePos + filenamePrefix.length()));

//                     // Construire le chemin complet pour sauvegarder le fichier
//                     std::string uploadDirectory = location->getUploadStore();  // Obtenir le répertoire d'upload depuis la configuration
//                     std::string fullPath = uploadDirectory + "/" + filename;

//                     // Vérifier que le répertoire d'upload existe
//                     struct stat dirStat;
//                     if (stat(uploadDirectory.c_str(), &dirStat) != 0 || !S_ISDIR(dirStat.st_mode)) {
//                         std::cerr << "Upload directory does not exist: " << uploadDirectory << std::endl;
//                         response.setStatusCode(500);
//                         response.setBody("Upload directory does not exist.");
//                         return response;
//                     }

//                     // Sauvegarder le fichier
//                     std::ofstream file(fullPath.c_str(), std::ios::binary);
//                     if (file.is_open()) {
//                         file.write(fileData.c_str(), fileData.size());
//                         file.close();
//                         std::cout << "File saved: " << fullPath << std::endl;
//                     } else {
//                         std::cerr << "Failed to save file: " << fullPath << std::endl;
//                         response.setStatusCode(500);
//                         response.setBody("Failed to save file.");
//                         return response;
//                     }
//                 }
//             }
//         }
//     } else {
//         response.setStatusCode(400);
//         response.setBody("No boundary found in multipart request.");
//         return response;
//     }

//     response.setStatusCode(200);
//     response.setBody("File upload successful.");
//     return response;
// }

HttpResponse RequestHandler::generateAutoIndex(const std::string& fullPath, const std::string& requestPath) const {
    std::cout << RED << "RequestHandler::generateAutoIndex" << RESET << std::endl; // test
    std::stringstream ss;

    
    ss << "<html><head><title>Index of " << requestPath << "</title></head><body>";
    ss << "<h1>Index of " << requestPath << "</h1><ul>";

    DIR* dir = opendir(fullPath.c_str());
    if (dir) {
        struct dirent* entry;
        while ((entry = readdir(dir)) != NULL) {
            std::string name = entry->d_name;
            if (name == ".")
                continue;
            ss << "<li><a href=\"" << name << "\">" << name << "</a></li>";
        }
        closedir(dir);
    } else {
        ss << "<li>Error reading directory.</li>";
    }

    ss << "</ul></body></html>";

    
    HttpResponse response;
    response.setStatusCode(200);
    response.setBody(ss.str());
    response.setHeader("Content-Type", "text/html; charset=UTF-8");
    response.setHeader("Connection", "close");

    return response; 
}

std::string RequestHandler::getMimeType(const std::string& extension) const {
    if (extension == "html" || extension == "htm")
        return "text/html";
    if (extension == "css")
        return "text/css";
    if (extension == "js")
        return "application/javascript";
    if (extension == "png")
        return "image/png";
    if (extension == "jpg" || extension == "jpeg")
        return "image/jpeg";
    if (extension == "gif")
        return "image/gif";
    if (extension == "txt")
        return "text/plain";
    // Ajouter d'autres types MIME selon les besoins
    return "application/octet-stream"; // Type par défaut
}

bool RequestHandler::isPathSecure(const std::string& root, const std::string& fullPath) const {
    char realRoot[PATH_MAX];
    char realFullPath[PATH_MAX];

    if (realpath(root.c_str(), realRoot) == NULL) {
        std::cerr << "Invalid root path: " << root << std::endl;
        return false;
    }

    if (realpath(fullPath.c_str(), realFullPath) == NULL) {
        std::cerr << "Invalid file path: " << fullPath << std::endl;
        return false;
    }

    std::string realRootStr(realRoot);
    std::string realFullPathStr(realFullPath);

    // Vérifier que fullPath commence par root
    if (realFullPathStr.find(realRootStr) != 0) {
        std::cerr << "Path traversal attempt detected: " << fullPath << std::endl;
        return false;
    }

    return true;
}

std::string RequestHandler::getErrorPageFullPath(int statusCode, const Location* location, const Server* server) const {
    if (location && !location->getErrorPageFullPath(statusCode).empty()) {
        return location->getErrorPageFullPath(statusCode);
    } else if (server && !server->getErrorPageFullPath(statusCode).empty()) {
        return server->getErrorPageFullPath(statusCode);
    } else {
        return config_.getErrorPageFullPath(statusCode);
    }
}

std::string RequestHandler::join(const std::vector<std::string>& elements, const std::string& delimiter) const {
    std::ostringstream os;
    for (size_t i = 0; i < elements.size(); ++i) {
        os << elements[i];
        if (i < elements.size() - 1) {
            os << delimiter;
        }
    }
    return os.str();
}
// HttpRequest.cpp
#include "../includes/HttpRequest.hpp"
#include "../includes/Color_Macros.hpp"
#include <sstream>
#include <algorithm>
#include <cctype>
#include <iostream>

HttpRequest::HttpRequest()
    : rawData_(""), 
      method_(""), 
      rawPath_(""), 
      path_(""), 
      queryString_(""), 
      httpVersion_(""), 
      body_(""), 
      contentLength_(0), 
      headersParsed_(false), 
      state_(REQUEST_LINE),
      parseError_(false),
      parseErrorCode_(0)
{
}

HttpRequest::~HttpRequest() {
}

void HttpRequest::appendData(const std::string& data) {
    rawData_ += data;
}

bool HttpRequest::isComplete() const {
    if (!headersParsed_) {
        // std::cout << "HttpRequest::isComplete()  : headers are not parsed " << std::endl;//test
        return false;
    }
    // std::cout << "HttpRequest::isComplete()  : body_ size: " << body_.size() << " / " << contentLength_ << std::endl;//test

    return body_.size() >= contentLength_;
}

bool HttpRequest::parseRequest() {
    std::istringstream stream(rawData_);
    std::string line;

    while (state_ != COMPLETE && std::getline(stream, line)) {
        if (state_ == REQUEST_LINE) {
            if (line.empty()) {
                // Requête incomplète
                return false;
            }
            parseRequestLine(line);
            // Vérifier la version HTTP
            if (httpVersion_ != "HTTP/1.1" && httpVersion_ != "HTTP/1.0") {
                std::cerr << "Unsupported HTTP version: " << httpVersion_ << std::endl;
                parseError_ = true;
                parseErrorCode_ = 505; // HTTP Version Not Supported
                return false;
            }
            state_ = HEADERS;
        } else if (state_ == HEADERS) {
            if (line == "\r" || line.empty()) {
                headersParsed_ = true;
                std::map<std::string, std::string>::iterator it = headers_.find("Content-Length");
                if (it != headers_.end()) {
                    std::istringstream lengthStream(it->second);
                    int length;
                    if (!(lengthStream >> length) || length < 0) {
                        std::cerr << "Invalid Content-Length: " << it->second << std::endl;
                        parseError_ = true;
                        parseErrorCode_ = 400; // Bad Request
                        return false;
                    }
                    contentLength_ = static_cast<size_t>(length);
                } else {
                    contentLength_ = 0;
                }

                // Vérifier la présence de Content-Type si la méthode est POST
                if (method_ == "POST") {
                    if (headers_.find("Content-Type") == headers_.end()) {
                        std::cerr << "Missing Content-Type header in POST request." << std::endl;
                        parseError_ = true;
                        parseErrorCode_ = 400; // Bad Request
                        return false;
                    }
                    // Vous pouvez ajouter des vérifications supplémentaires sur le Content-Type ici
                    //verifier que le content type est soit url encoded soit multipart form
                }

                state_ = (contentLength_ > 0) ? BODY : COMPLETE;
            } else {
                parseHeaderLine(line);
            }
        } else if (state_ == BODY) {
            size_t bodyStartPos = rawData_.find("\r\n\r\n");
            if (bodyStartPos != std::string::npos) {
                bodyStartPos += 4; // Passer les "\r\n\r\n"
                body_ = rawData_.substr(bodyStartPos, contentLength_);
                if (body_.size() >= contentLength_) {
                    state_ = COMPLETE;
                } else {
                    return false; // Attendre plus de données
                }
            } else {
                return false; // Attendre plus de données
            }
        }
    }
    return state_ == COMPLETE;
}

void HttpRequest::parseRequestLine(const std::string& line) {
    std::istringstream lineStream(line);
    lineStream >> method_ >> rawPath_ >> httpVersion_;

    // Supprimer le retour chariot de httpVersion_ s'il est présent
    if (!httpVersion_.empty() && httpVersion_[httpVersion_.size() - 1] == '\r') {
        httpVersion_.erase(httpVersion_.size() - 1);
    }

    // Retirer la query string du rawPath_
    size_t queryPos = rawPath_.find('?');
    if (queryPos != std::string::npos) {
        queryString_ = rawPath_.substr(queryPos + 1); // Stocker la query string
        rawPath_ = rawPath_.substr(0, queryPos); // Garder uniquement la partie avant le '?'
    } else {
        queryString_.clear(); // Aucune query string, on vide la variable
    }

    // Normaliser le chemin
    path_ = normalizePath(rawPath_);

    // std::cout << "Parsed request line: " << method_ << " " << path_ << " " << httpVersion_ << std::endl; // test
}

std::string HttpRequest::normalizePath(const std::string& path) const {
    std::string normalizedPath;
    bool prevWasSlash = false;
    for (size_t i = 0; i < path.length(); ++i) {
        char c = path[i];
        if (c == '/') {
            if (!prevWasSlash) {
                normalizedPath += c;
                prevWasSlash = true;
            }
        } else {
            normalizedPath += c;
            prevWasSlash = false;
        }
    }
    return normalizedPath;
}

void HttpRequest::parseHeaderLine(const std::string& line) {
    std::string::size_type pos = line.find(':');
    if (pos != std::string::npos) {
        std::string headerName = line.substr(0, pos);
        std::string headerValue = line.substr(pos + 1);

        // Supprimer les espaces
        headerName.erase(headerName.find_last_not_of(" \t\r\n") + 1);
        headerValue.erase(0, headerValue.find_first_not_of(" \t\r\n"));
        headerValue.erase(headerValue.find_last_not_of(" \t\r\n") + 1);

        headers_[headerName] = headerValue;

        // std::cout << "HttpRequest::parseRequestLine  : Parsed header: " << headerName << " = '" << headerValue << "'"  << std::endl;//test
    }
}

const std::string& HttpRequest::getMethod() const {
    return method_;
}

const std::string& HttpRequest::getPath() const {
    return path_;
}

const std::string& HttpRequest::getRawPath() const {
    return rawPath_;
}

const std::string& HttpRequest::getHttpVersion() const {
    return httpVersion_;
}

std::string HttpRequest::getHeader(const std::string& headerName) const {
    std::map<std::string, std::string>::const_iterator it = headers_.find(headerName);
    if (it != headers_.end()) {
        return it->second;
    }
    return "";
}

const std::string& HttpRequest::getBody() const {
    return body_;
}

std::string HttpRequest::getQueryString() const {
        return queryString_;
}

bool HttpRequest::hasParseError() const {
    return parseError_;
}

int HttpRequest::getParseErrorCode() const {
    return parseErrorCode_;
}

void HttpRequest::displayContent() const
{
    std::cout << RED <<"HttpRequest::displayContent" << RESET << std::endl;
    std::cout << RED <<"Method : "<< method_ << RESET << std::endl;
    std::cout << RED <<"Path : " << path_ <<RESET << std::endl;
    std::cout << RED <<"HttpVersion : " << httpVersion_ << RESET << std::endl;
    // std::cout << RED <<"Headers" << RESET << std::endl;
    std::cout << RED <<"Body : " << body_ << RESET << std::endl;
}

void HttpRequest::reset() {
    method_.clear();
    path_.clear();
    httpVersion_.clear();
    body_.clear();
    rawData_.clear();
    contentLength_ = 0;
    headersParsed_ = false;
    state_ = REQUEST_LINE;
    headers_.clear();
}
#include <fstream>
#include <sstream>
#include <iostream>
#include "Utils.hpp"
#include "Server.hpp"
#include "HttpResponse.hpp"
#include "Color_Macros.hpp"

// std::string errorPagePath = root + errorPageUri;
HttpResponse handleError(int statusCode, const std::string &errorPagePath) 
{
    std::cout << RED <<"error page path : "<< errorPagePath << RESET << std::endl;//test
    HttpResponse response;
    response.setStatusCode(statusCode);
    if (!errorPagePath.empty()){    
        std::ifstream errorFile(errorPagePath.c_str(), std::ios::in | std::ios::binary);
        if (errorFile.is_open()) {
            std::cout << "error File found" << std::endl;//test
            std::stringstream buffer;
            buffer << errorFile.rdbuf();
            std::string errorContent = buffer.str();
            errorFile.close();
            response.setBody(errorContent);
        } else {
            std::cout << "error file not found" << std::endl;//test
            response.setBody("Error " + toString(statusCode));
        }
    } else {
        // Message d'erreur par défaut
        std::cout << "default error message" << std::endl;//test
        switch (statusCode) {
            case 400: response.setBody("Bad Request"); break;
            case 401: response.setBody("Unauthorized"); break;
            case 403: response.setBody("Forbidden"); break;
            case 404: response.setBody("Not Found"); break;
            case 405: response.setBody("Method Not Allowed"); break;
            case 408: response.setBody("Request Timeout"); break;
            case 500: response.setBody("Internal Server Error"); break;
            case 501: response.setBody("Not Implemented"); break;
            case 502: response.setBody("Bad Gateway"); break;
            case 503: response.setBody("Service Unavailable"); break;
            case 504: response.setBody("Gateway Timeout"); break;
            default: response.setBody("Error " + toString(statusCode));
        }
    }

    // Définir le Content-Type
    response.setHeader("Content-Type", "text/html; charset=UTF-8");
    response.setHeader("Connection", "close");

    return response;
}

// HttpResponse handleError(int statusCode, std::string &errorPagePath) 
// {
//     std::cout << "handle error" << std::endl;//test
//     HttpResponse response;
//     response.setStatusCode(statusCode);

//     // Récupérer la page d'erreur personnalisée si disponible
//     std::string errorPageUri = "";
//     std::string root = "";
//     if (server) {
//         errorPageUri = server->getErrorPage(statusCode);
//         root = server->getRoot();
//     } else if (config) {
//         errorPageUri = config->getErrorPage(statusCode);
//         root = config->getRoot();

//     }

//     if (!errorPageUri.empty()) {
//         // Construire le chemin complet de la page d'erreur
//         std::string errorPagePath = root + errorPageUri;
//         std::cout << "error page path : "<< errorPagePath << std::endl;//test
//         std::ifstream errorFile(errorPagePath.c_str(), std::ios::in | std::ios::binary);
//         if (errorFile.is_open()) {
//             std::cout << "error File found" << std::endl;//test
//             std::stringstream buffer;
//             buffer << errorFile.rdbuf();
//             std::string errorContent = buffer.str();
//             errorFile.close();
//             response.setBody(errorContent);
//         } else {
//             response.setBody("Error " + toString(statusCode));
//         }
//     } else {
//         // Message d'erreur par défaut
//         switch (statusCode) {
//             case 400: response.setBody("Bad Request"); break;
//             case 401: response.setBody("Unauthorized"); break;
//             case 403: response.setBody("Forbidden"); break;
//             case 404: response.setBody("Not Found"); break;
//             case 405: response.setBody("Method Not Allowed"); break;
//             case 408: response.setBody("Request Timeout"); break;
//             case 500: response.setBody("Internal Server Error"); break;
//             case 501: response.setBody("Not Implemented"); break;
//             case 502: response.setBody("Bad Gateway"); break;
//             case 503: response.setBody("Service Unavailable"); break;
//             case 504: response.setBody("Gateway Timeout"); break;
//             default: response.setBody("Error " + toString(statusCode));
//         }
//     }

//     // Définir le Content-Type
//     response.setHeader("Content-Type", "text/html");

//     return response;
// }
// // Ajoutez d'autres surcharges si nécessaire pour différents types